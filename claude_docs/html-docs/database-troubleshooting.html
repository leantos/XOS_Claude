<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Troubleshooting Guide - XOS Framework</title>
    <link rel="icon" type="image/png" href="xos-docs.png">
    <link rel="shortcut icon" type="image/png" href="xos-docs.png">
    <link rel="apple-touch-icon" href="xos-docs.png">
    <link rel="stylesheet" href="style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-dark.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</head>
<body data-theme="dark">
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <!-- Theme Toggle Button -->
            <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
                <i class="bi bi-moon-fill" id="theme-icon"></i>
                <span id="theme-text">Dark</span>
            </button>
            
            <h3><i class="bi bi-house"></i> Navigation</h3>
            <ul>
                <li><a href="../../index.html"><i class="bi bi-arrow-left"></i> Back to Home</a></li>
                <li><a href="#connection-configuration"><i class="bi bi-link-45deg"></i> Connection & Configuration</a></li>
                <li><a href="#xos-postgresql"><i class="bi bi-server"></i> XOS Framework & PostgreSQL</a></li>
                <li><a href="#entity-framework"><i class="bi bi-diagram-3"></i> Entity Framework Issues</a></li>
                <li><a href="#migration-issues"><i class="bi bi-arrow-up-circle"></i> Migration Issues</a></li>
            </ul>
            
            <h3><i class="bi bi-bug"></i> Quick Fixes</h3>
            <ul>
                <li><a href="#query-performance"><i class="bi bi-speedometer2"></i> Query Performance</a></li>
                <li><a href="#data-consistency"><i class="bi bi-check2-square"></i> Data Consistency</a></li>
                <li><a href="#transaction-management"><i class="bi bi-arrow-repeat"></i> Transaction Management</a></li>
                <li><a href="#security-issues"><i class="bi bi-shield-check"></i> Security Issues</a></li>
            </ul>

            <h3><i class="bi bi-life-preserver"></i> Other Troubleshooting</h3>
            <ul>
                <li><a href="frontend-troubleshooting.html"><i class="bi bi-palette"></i> Frontend Issues</a></li>
                <li><a href="backend-troubleshooting.html"><i class="bi bi-server"></i> Backend Issues</a></li>
                <li><a href="api-troubleshooting.html"><i class="bi bi-cloud-arrow-up"></i> API Issues</a></li>
                <li><a href="testing-troubleshooting.html"><i class="bi bi-check2-square"></i> Testing Issues</a></li>
            </ul>
        </nav>

        <!-- Main Content -->
        <main class="main-content">

            <h1><i class="bi bi-database"></i> Database Issues & Solutions</h1>
            
            <div class="alert alert-info">
                <h3><i class="bi bi-info-circle"></i> About This Guide</h3>
                <p>This document tracks database-related issues encountered during development, focusing on PostgreSQL, Entity Framework, migrations, and data access patterns.</p>
            </div>

            <section id="connection-configuration">
                <h2><i class="bi bi-link-45deg"></i> Connection & Configuration Issues</h2>
                
                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>PostgreSQL Connection Failures</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> "Connection refused" or "server closed the connection unexpectedly"</p>
                        <p><strong>Root Cause:</strong> Incorrect connection string, PostgreSQL not running, or firewall blocking</p>
                        <p><strong>Solution:</strong> Verify connection string format and PostgreSQL service status</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>PostgreSQL Connection String</span>
                                <button class="copy-btn" onclick="copyCode(this, 'connection-string')">Copy</button>
                            </div>
                            <pre id="connection-string"><code class="language-text">Server=localhost;Port=5432;Database=CVS_Claude;User Id=postgres;Password=admin;CommandTimeout=30;Timeout=30;</code></pre>
                        </div>
                        <p><strong>Applied In:</strong> appsettings.json configuration</p>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Connection Pool Exhaustion</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> "Sorry, too many clients already" errors under load</p>
                        <p><strong>Root Cause:</strong> Database contexts not properly disposed</p>
                        <p><strong>Solution:</strong> Use `using` statements for all database operations</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Proper Context Disposal</span>
                                <button class="copy-btn" onclick="copyCode(this, 'context-disposal')">Copy</button>
                            </div>
                            <pre id="context-disposal"><code class="language-csharp">// Wrong - connection leak
public async Task<User> GetUserAsync(int id)
{
    var context = new AppDbContext(_options);
    return await context.Users.FindAsync(id);
    // Context never disposed - connection leak!
}

// Correct - proper disposal
public async Task<User> GetUserAsync(int id)
{
    using var context = new AppDbContext(_options);
    return await context.Users.FindAsync(id);
} // Context automatically disposed</code></pre>
                        </div>
                        <p><strong>Pattern:</strong> Always dispose database contexts properly</p>
                    </div>
                </div>
            </section>

            <section id="xos-postgresql">
                <h2><i class="bi bi-server"></i> XOS Framework & PostgreSQL Issues</h2>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>XOS ExecuteReaderAsync Returns Empty Results</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Database queries execute without error but return no data</p>
                        <p><strong>Root Cause:</strong> Incorrect parameter binding or context not set</p>
                        <p><strong>Solution:</strong> Ensure proper parameter naming and context setting</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Correct XOS Pattern</span>
                                <button class="copy-btn" onclick="copyCode(this, 'xos-pattern')">Copy</button>
                            </div>
                            <pre id="xos-pattern"><code class="language-csharp">// Correct XOS pattern
SetUserContext(clientId, siteId, userId); // Set context first

var parameters = new Dictionary<string, object>
{
    { "@UserId", userId },           // Note @ prefix
    { "@ClientId", ClientID },       // Use base class properties
    { "@SiteId", SiteID },
    { "@IsDeleted", false }
};

var query = @"
    SELECT login_id, user_name, user_id 
    FROM cvs_user_logins 
    WHERE user_id = @UserId 
    AND client_id = @ClientId 
    AND site_id = @SiteId 
    AND is_deleted = @IsDeleted";

var results = await ExecuteReaderAsync(query, parameters, MapRowToUserLogin);</code></pre>
                        </div>
                        <p><strong>Applied In:</strong> All UserLogin database operations</p>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>PostgreSQL Query Performance Degradation</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> UserLogin search operations taking >2 seconds with large datasets</p>
                        <p><strong>Root Cause:</strong> Missing indexes on commonly queried columns</p>
                        <p><strong>Solution:</strong> Add composite indexes for multi-tenant queries</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Performance Indexes</span>
                                <button class="copy-btn" onclick="copyCode(this, 'performance-indexes')">Copy</button>
                            </div>
                            <pre id="performance-indexes"><code class="language-sql">-- Add performance indexes for UserLogin
CREATE INDEX CONCURRENTLY idx_cvs_user_logins_tenant_status 
ON cvs_user_logins(client_id, site_id, status, is_deleted) 
WHERE is_active = true;

CREATE INDEX CONCURRENTLY idx_cvs_user_logins_user_time 
ON cvs_user_logins(user_id, login_time DESC) 
WHERE is_deleted = false;

CREATE INDEX CONCURRENTLY idx_cvs_user_logins_session_lookup 
ON cvs_user_logins(session_id, status) 
WHERE is_active = true;

-- Analyze query performance
EXPLAIN ANALYZE 
SELECT * FROM cvs_user_logins 
WHERE client_id = 1 AND site_id = 1 AND status = 1 
ORDER BY login_time DESC LIMIT 50;</code></pre>
                        </div>
                        <p><strong>Applied In:</strong> UserLogin search and session management queries</p>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Multi-Tenant Data Leakage</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Users seeing login records from other clients/sites</p>
                        <p><strong>Root Cause:</strong> Missing tenant isolation in WHERE clauses</p>
                        <p><strong>Solution:</strong> Always include client_id and site_id filters in all queries</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Multi-Tenant Query Template</span>
                                <button class="copy-btn" onclick="copyCode(this, 'tenant-query')">Copy</button>
                            </div>
                            <pre id="tenant-query"><code class="language-sql">-- Template for all multi-tenant queries
WHERE client_id = @ClientId 
AND site_id = @SiteId 
AND is_deleted = false
-- ... other conditions</code></pre>
                        </div>
                        <p><strong>Pattern:</strong> Every query must include tenant isolation</p>
                        <p><strong>Applied In:</strong> All UserLogin data operations</p>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Database Timeout Errors</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> "Timeout expired" errors on long-running queries</p>
                        <p><strong>Root Cause:</strong> Default command timeout too short for complex operations</p>
                        <p><strong>Solution:</strong> Configure appropriate command timeout</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Command Timeout Configuration</span>
                                <button class="copy-btn" onclick="copyCode(this, 'command-timeout')">Copy</button>
                            </div>
                            <pre id="command-timeout"><code class="language-csharp">services.AddDbContext<AppDbContext>(options =>
{
    options.UseNpgsql(connectionString, npgsqlOptions =>
    {
        npgsqlOptions.CommandTimeout(60); // 60 seconds
    });
});</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section id="entity-framework">
                <h2><i class="bi bi-diagram-3"></i> Entity Framework Issues</h2>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Entity Not Found After Insert</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Entity inserted successfully but can't retrieve it immediately</p>
                        <p><strong>Root Cause:</strong> Entity not saved to database due to missing SaveChanges()</p>
                        <p><strong>Solution:</strong> Always call SaveChanges() or SaveChangesAsync()</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Correct Save Pattern</span>
                                <button class="copy-btn" onclick="copyCode(this, 'save-changes')">Copy</button>
                            </div>
                            <pre id="save-changes"><code class="language-csharp">public async Task<User> CreateUserAsync(User user)
{
    _context.Users.Add(user);
    await _context.SaveChangesAsync(); // Essential!
    return user;
}</code></pre>
                        </div>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Tracking Conflicts in Entity Framework</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> "The instance of entity type cannot be tracked" errors</p>
                        <p><strong>Root Cause:</strong> Multiple instances of same entity being tracked</p>
                        <p><strong>Solution:</strong> Use AsNoTracking() for read operations or properly manage tracked entities</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Entity Tracking Solutions</span>
                                <button class="copy-btn" onclick="copyCode(this, 'entity-tracking')">Copy</button>
                            </div>
                            <pre id="entity-tracking"><code class="language-csharp">// For read-only operations
public async Task<List<User>> GetAllUsersAsync()
{
    return await _context.Users
        .AsNoTracking()
        .ToListAsync();
}

// For updates, check if entity is already tracked
public async Task UpdateUserAsync(User user)
{
    var existingEntity = _context.Entry(user);
    if (existingEntity.State == EntityState.Detached)
    {
        _context.Users.Update(user);
    }
    await _context.SaveChangesAsync();
}</code></pre>
                        </div>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Circular Reference Issues in Entity Relationships</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Stack overflow exceptions or infinite loops during serialization</p>
                        <p><strong>Root Cause:</strong> Bidirectional navigation properties causing circular references</p>
                        <p><strong>Solution:</strong> Use DTO projections or configure JSON serializer options</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Circular Reference Solutions</span>
                                <button class="copy-btn" onclick="copyCode(this, 'circular-reference')">Copy</button>
                            </div>
                            <pre id="circular-reference"><code class="language-csharp">// Domain models (can have circular references)
public class User
{
    public int Id { get; set; }
    public List<Order> Orders { get; set; }
}

public class Order
{
    public int Id { get; set; }
    public User User { get; set; } // Circular reference
}

// Use DTOs for API responses
public class UserDto
{
    public int Id { get; set; }
    public List<OrderSummaryDto> Orders { get; set; }
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section id="migration-issues">
                <h2><i class="bi bi-arrow-up-circle"></i> Migration Issues</h2>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Migration Conflicts Between Developers</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> "Column already exists" or conflicting migration errors</p>
                        <p><strong>Root Cause:</strong> Multiple developers creating migrations simultaneously</p>
                        <p><strong>Solution:</strong> Coordinate migrations and always pull latest before creating</p>
                        <p><strong>Pattern:</strong> One developer creates migrations at a time, others pull and apply</p>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Data Loss During Migrations</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Existing data disappears after running migrations</p>
                        <p><strong>Root Cause:</strong> Migration dropping and recreating tables instead of altering</p>
                        <p><strong>Solution:</strong> Carefully review generated migrations before applying</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Safe Migration Pattern</span>
                                <button class="copy-btn" onclick="copyCode(this, 'safe-migration')">Copy</button>
                            </div>
                            <pre id="safe-migration"><code class="language-csharp">// Review migration before applying
protected override void Up(MigrationBuilder migrationBuilder)
{
    // Ensure this adds column, doesn't drop table
    migrationBuilder.AddColumn<string>(
        name: "NewColumn",
        table: "Users",
        nullable: true);
        
    // NOT: migrationBuilder.DropTable("Users");
}</code></pre>
                        </div>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Migration Rollback Failures</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Cannot rollback migrations due to data constraints</p>
                        <p><strong>Root Cause:</strong> Rollback operations not properly defined in Down() methods</p>
                        <p><strong>Solution:</strong> Always implement proper Down() methods in migrations</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Rollback Pattern</span>
                                <button class="copy-btn" onclick="copyCode(this, 'rollback-pattern')">Copy</button>
                            </div>
                            <pre id="rollback-pattern"><code class="language-csharp">protected override void Down(MigrationBuilder migrationBuilder)
{
    // Proper rollback of the Up() operation
    migrationBuilder.DropColumn(
        name: "NewColumn",
        table: "Users");
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section id="query-performance">
                <h2><i class="bi bi-speedometer2"></i> Query Performance Issues</h2>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>N+1 Query Problems</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Large number of database queries for simple operations</p>
                        <p><strong>Root Cause:</strong> Lazy loading causing additional queries in loops</p>
                        <p><strong>Solution:</strong> Use Include() for explicit loading or projection</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>N+1 Query Solutions</span>
                                <button class="copy-btn" onclick="copyCode(this, 'n-plus-one')">Copy</button>
                            </div>
                            <pre id="n-plus-one"><code class="language-csharp">// Problem: N+1 queries
var users = await _context.Users.ToListAsync();
foreach(var user in users)
{
    Console.WriteLine(user.Orders.Count); // Each access hits database again
}

// Solution: Explicit loading
var users = await _context.Users
    .Include(u => u.Orders)
    .ToListAsync();

// Or use projection for better performance
var userSummaries = await _context.Users
    .Select(u => new UserSummaryDto
    {
        Id = u.Id,
        Name = u.Name,
        OrderCount = u.Orders.Count()
    })
    .ToListAsync();</code></pre>
                        </div>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Inefficient Query Generation</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Slow database operations with complex LINQ queries</p>
                        <p><strong>Root Cause:</strong> LINQ generating suboptimal SQL</p>
                        <p><strong>Solution:</strong> Use raw SQL for complex queries or optimize LINQ</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Query Optimization</span>
                                <button class="copy-btn" onclick="copyCode(this, 'query-optimization')">Copy</button>
                            </div>
                            <pre id="query-optimization"><code class="language-csharp">// Complex LINQ might generate inefficient SQL
var result = await _context.Orders
    .Where(o => o.Items.Any(i => i.Category.Name == "Electronics"))
    .Include(o => o.Customer)
    .ToListAsync();

// Consider raw SQL for better performance
var result = await _context.Orders
    .FromSqlRaw(@"
        SELECT o.* FROM Orders o 
        INNER JOIN OrderItems oi ON o.Id = oi.OrderId
        INNER JOIN Items i ON oi.ItemId = i.Id
        INNER JOIN Categories c ON i.CategoryId = c.Id
        WHERE c.Name = 'Electronics'")
    .Include(o => o.Customer)
    .ToListAsync();</code></pre>
                        </div>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Missing Database Indexes</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Slow queries on frequently searched columns</p>
                        <p><strong>Root Cause:</strong> No indexes on columns used in WHERE clauses</p>
                        <p><strong>Solution:</strong> Add appropriate indexes via migrations</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Index Creation</span>
                                <button class="copy-btn" onclick="copyCode(this, 'index-creation')">Copy</button>
                            </div>
                            <pre id="index-creation"><code class="language-csharp">protected override void Up(MigrationBuilder migrationBuilder)
{
    // Add index on frequently queried column
    migrationBuilder.CreateIndex(
        name: "IX_Users_Email",
        table: "Users",
        column: "Email",
        unique: true);
        
    // Composite index for multiple column queries
    migrationBuilder.CreateIndex(
        name: "IX_Orders_CustomerId_Status",
        table: "Orders",
        columns: new[] { "CustomerId", "Status" });
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section id="data-consistency">
                <h2><i class="bi bi-check2-square"></i> Data Consistency Issues</h2>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Race Conditions in Concurrent Updates</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Data corruption or lost updates under concurrent access</p>
                        <p><strong>Root Cause:</strong> No concurrency control mechanism</p>
                        <p><strong>Solution:</strong> Implement optimistic or pessimistic concurrency control</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Optimistic Concurrency</span>
                                <button class="copy-btn" onclick="copyCode(this, 'concurrency-control')">Copy</button>
                            </div>
                            <pre id="concurrency-control"><code class="language-csharp">// Optimistic concurrency with version field
public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
    [Timestamp]
    public byte[] Version { get; set; } // Concurrency token
}

// Handle concurrency conflicts
try
{
    await _context.SaveChangesAsync();
}
catch (DbUpdateConcurrencyException)
{
    // Handle conflict - refresh and retry, or show user the conflict
    throw new ConcurrencyException("Another user modified this record");
}</code></pre>
                        </div>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Orphaned Records After Deletions</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Related records remain after parent record deletion</p>
                        <p><strong>Root Cause:</strong> Cascade delete not configured properly</p>
                        <p><strong>Solution:</strong> Configure appropriate cascade behaviors</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Cascade Delete Configuration</span>
                                <button class="copy-btn" onclick="copyCode(this, 'cascade-delete')">Copy</button>
                            </div>
                            <pre id="cascade-delete"><code class="language-csharp">protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Order>()
        .HasMany(o => o.Items)
        .WithOne(i => i.Order)
        .OnDelete(DeleteBehavior.Cascade); // Delete items when order is deleted
        
    modelBuilder.Entity<User>()
        .HasMany(u => u.Orders)
        .WithOne(o => o.User)
        .OnDelete(DeleteBehavior.Restrict); // Prevent user deletion if they have orders
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section id="transaction-management">
                <h2><i class="bi bi-arrow-repeat"></i> Transaction Management Issues</h2>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Partial Data Saves in Multi-Step Operations</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Some operations succeed while others fail, leaving inconsistent state</p>
                        <p><strong>Root Cause:</strong> No transaction wrapping multi-step operations</p>
                        <p><strong>Solution:</strong> Use database transactions for multi-step operations</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Transaction Management</span>
                                <button class="copy-btn" onclick="copyCode(this, 'transaction-management')">Copy</button>
                            </div>
                            <pre id="transaction-management"><code class="language-csharp">public async Task<Order> CreateOrderWithItemsAsync(CreateOrderRequest request)
{
    using var transaction = await _context.Database.BeginTransactionAsync();
    try
    {
        // Step 1: Create order
        var order = new Order { CustomerId = request.CustomerId };
        _context.Orders.Add(order);
        await _context.SaveChangesAsync();
        
        // Step 2: Add order items
        foreach(var item in request.Items)
        {
            _context.OrderItems.Add(new OrderItem 
            { 
                OrderId = order.Id, 
                ItemId = item.ItemId,
                Quantity = item.Quantity 
            });
        }
        await _context.SaveChangesAsync();
        
        // Step 3: Update inventory
        await _inventoryService.ReserveItemsAsync(request.Items);
        
        await transaction.CommitAsync();
        return order;
    }
    catch
    {
        await transaction.RollbackAsync();
        throw;
    }
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section id="security-issues">
                <h2><i class="bi bi-shield-check"></i> Security Issues</h2>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>SQL Injection Vulnerabilities</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Potential for malicious SQL execution through user input</p>
                        <p><strong>Root Cause:</strong> String concatenation for dynamic queries</p>
                        <p><strong>Solution:</strong> Use parameterized queries or LINQ</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>SQL Injection Prevention</span>
                                <button class="copy-btn" onclick="copyCode(this, 'sql-injection')">Copy</button>
                            </div>
                            <pre id="sql-injection"><code class="language-csharp">// Vulnerable to SQL injection
public async Task<User> GetUserByEmailAsync(string email)
{
    var sql = $"SELECT * FROM Users WHERE Email = '{email}'";
    return await _context.Users.FromSqlRaw(sql).FirstOrDefaultAsync();
}

// Safe parameterized query
public async Task<User> GetUserByEmailAsync(string email)
{
    return await _context.Users
        .FromSqlRaw("SELECT * FROM Users WHERE Email = {0}", email)
        .FirstOrDefaultAsync();
}

// Better: Use LINQ (automatically parameterized)
public async Task<User> GetUserByEmailAsync(string email)
{
    return await _context.Users
        .Where(u => u.Email == email)
        .FirstOrDefaultAsync();
}</code></pre>
                        </div>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <h3>Sensitive Data Exposure in Logs</h3>
                        <span class="collapsible-toggle">▼</span>
                    </div>
                    <div class="collapsible-content">
                        <p><strong>Symptoms:</strong> Database queries with sensitive data appearing in logs</p>
                        <p><strong>Root Cause:</strong> EF Core logging query parameters</p>
                        <p><strong>Solution:</strong> Configure logging to exclude sensitive data</p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Secure Logging Configuration</span>
                                <button class="copy-btn" onclick="copyCode(this, 'secure-logging')">Copy</button>
                            </div>
                            <pre id="secure-logging"><code class="language-csharp">services.AddDbContext<AppDbContext>(options =>
{
    options.UseNpgsql(connectionString);
    options.EnableSensitiveDataLogging(false); // Don't log parameter values
    options.EnableDetailedErrors(false); // Don't include sensitive details in errors
});</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section id="best-practices">
                <h2><i class="bi bi-star"></i> Database Best Practices</h2>
                
                <div class="nav-grid">
                    <div class="nav-card">
                        <h4>Entity Configuration</h4>
                        <ul>
                            <li>Use Fluent API for complex configurations</li>
                            <li>Define relationships explicitly</li>
                            <li>Set appropriate data types and constraints</li>
                            <li>Configure indexes for frequently queried columns</li>
                        </ul>
                    </div>

                    <div class="nav-card">
                        <h4>Query Optimization</h4>
                        <ul>
                            <li>Use AsNoTracking() for read-only operations</li>
                            <li>Include related data explicitly to avoid N+1 queries</li>
                            <li>Use projection for performance-critical queries</li>
                            <li>Monitor and optimize slow queries</li>
                        </ul>
                    </div>

                    <div class="nav-card">
                        <h4>Transaction Management</h4>
                        <ul>
                            <li>Use transactions for multi-step operations</li>
                            <li>Keep transactions as short as possible</li>
                            <li>Handle transaction failures gracefully</li>
                            <li>Avoid nested transactions</li>
                        </ul>
                    </div>

                    <div class="nav-card">
                        <h4>Migration Safety</h4>
                        <ul>
                            <li>Always review generated migrations</li>
                            <li>Test migrations on copy of production data</li>
                            <li>Implement proper rollback procedures</li>
                            <li>Coordinate migration creation in team environments</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="usage-guide">
                <h2><i class="bi bi-book"></i> How to Use This Guide</h2>
                <div class="nav-grid">
                    <div class="nav-card">
                        <h4>Check Connection Issues</h4>
                        <p>Verify connection strings and service status before troubleshooting other issues.</p>
                    </div>
                    <div class="nav-card">
                        <h4>Review Query Performance</h4>
                        <p>Look for N+1 queries and missing indexes that could impact performance.</p>
                    </div>
                    <div class="nav-card">
                        <h4>Validate Entity Configurations</h4>
                        <p>Ensure proper relationships and constraints are configured correctly.</p>
                    </div>
                    <div class="nav-card">
                        <h4>Test Migration Safety</h4>
                        <p>Review migrations before applying to production environments.</p>
                    </div>
                </div>
            </section>

            <div class="footer">
                <p><em>Database Troubleshooting Guide</em><br>
                <em>Last Updated: August 21, 2025</em><br>
                <em>Maintainer: Development Team</em></p>
                
                <p><strong>Need More Help?</strong> Check <a href="../../index.html">main documentation</a> or other troubleshooting guides: 
                <a href="frontend-troubleshooting.html">Frontend</a> | 
                <a href="backend-troubleshooting.html">Backend</a> | 
                <a href="api-troubleshooting.html">API</a> | 
                <a href="testing-troubleshooting.html">Testing</a></p>
            </div>
        </main>
    </div>

    <script>
        // Copy code functionality
        function copyCode(button, codeId) {
            const codeElement = document.getElementById(codeId);
            const text = codeElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        // Collapsible sections
        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('expanded');
        }

        // Search functionality
        function highlightText(text, searchTerm) {
            if (!searchTerm) return text;
            const regex = new RegExp(`(${searchTerm})`, 'gi');
            return text.replace(regex, '<span class="highlight">$1</span>');
        }

        document.getElementById('searchInput').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const content = document.querySelector('.main-content');
            const sections = content.querySelectorAll('section, h2, h3, p, li, td');
            
            // Remove previous highlights
            sections.forEach(section => {
                section.innerHTML = section.innerHTML.replace(/<span class="highlight">(.*?)<\/span>/gi, '$1');
            });
            
            if (searchTerm.length > 2) {
                sections.forEach(section => {
                    const text = section.textContent.toLowerCase();
                    if (text.includes(searchTerm)) {
                        section.innerHTML = highlightText(section.innerHTML, searchTerm);
                    }
                });

                // Auto-expand sections with search results
                document.querySelectorAll('.collapsible').forEach(collapsible => {
                    const text = collapsible.textContent.toLowerCase();
                    if (text.includes(searchTerm)) {
                        collapsible.classList.add('expanded');
                    }
                });
            }
        });

        // Theme Toggle Functionality
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('theme-icon');
            const themeText = document.getElementById('theme-text');
            const currentTheme = body.getAttribute('data-theme');
            
            if (currentTheme === 'dark') {
                body.setAttribute('data-theme', 'light');
                themeIcon.className = 'bi bi-sun-fill';
                themeText.textContent = 'Light';
                localStorage.setItem('preferred-theme', 'light');
            } else {
                body.setAttribute('data-theme', 'dark');
                themeIcon.className = 'bi bi-moon-fill';
                themeText.textContent = 'Dark';
                localStorage.setItem('preferred-theme', 'dark');
            }
        }

        // Load saved theme preference
        function loadTheme() {
            const savedTheme = localStorage.getItem('preferred-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const theme = savedTheme || (prefersDark ? 'dark' : 'light');
            
            const body = document.body;
            const themeIcon = document.getElementById('theme-icon');
            const themeText = document.getElementById('theme-text');
            
            body.setAttribute('data-theme', theme);
            
            if (theme === 'light') {
                themeIcon.className = 'bi bi-sun-fill';
                themeText.textContent = 'Light';
            } else {
                themeIcon.className = 'bi bi-moon-fill';
                themeText.textContent = 'Dark';
            }
        }

        // Initialize theme on page load
        document.addEventListener('DOMContentLoaded', loadTheme);
    </script>
</body>
</html>