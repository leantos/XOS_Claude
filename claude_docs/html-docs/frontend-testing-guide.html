<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>frontend-testing-guide - XOS Framework</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="favicon.png">
    <link rel="stylesheet" href="style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-dark.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</head>
<body data-theme="dark">
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar">
            <h3><i class="bi bi-arrow-left"></i> Quick Links</h3>
            <ul>
                <li><a href="README.html"><i class="bi bi-house"></i> Documentation Hub</a></li>
                <li><a href="CRITICAL_PATTERNS.html"><i class="bi bi-exclamation-triangle"></i> Critical Patterns</a></li>
                <li><a href="MODULE-DEVELOPMENT-GUIDE.html"><i class="bi bi-book"></i> Module Guide</a></li>
                <li><a href="SETUP.html"><i class="bi bi-gear"></i> Setup Guide</a></li>
            </ul>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <p># Frontend Testing Guide - React with TypeScript</p><p>A comprehensive guide for testing React applications with TypeScript using Jest and React Testing Library.</p><p><h2>Table of Contents</h2>
<ul><li><a href="#setup-and-configuration">Setup and Configuration</a></li><li><a href="#testing-fundamentals">Testing Fundamentals</a></li><li><a href="#component-testing">Component Testing</a></li><li><a href="#hook-testing">Hook Testing</a></li><li><a href="#async-testing">Async Testing</a></li><li><a href="#mocking-strategies">Mocking Strategies</a></li><li><a href="#integration-testing">Integration Testing</a></li><li><a href="#best-practices">Best Practices</a></li></ul></p><p><h2>Setup and Configuration</h2></p><p><h3>1. Install Testing Dependencies</h3></p><p><div class="code-block"><pre><code>bash
npm install --save-dev \
  @testing-library/react \
  @testing-library/jest-dom \
  @testing-library/user-event \
  @testing-library/react-hooks \
  jest \
  ts-jest \
  @types/jest \
  jest-environment-jsdom \
  msw
</code></pre></div></p><p><h3>2. Jest Configuration</h3></p><p><strong>jest.config.js</strong>:
<div class="code-block"><pre><code>javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  roots: ['<rootDir>/src'],
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
  collectCoverageFrom: [
    'src/*<em>/</em>.{ts,tsx}',
    '!src/*<em>/</em>.d.ts',
    '!src/index.tsx',
    '!src/serviceWorker.ts',
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
  moduleNameMapper: {
    '^@/(.<em>)
            
            <div class="footer">
                <p><em>Auto-generated from Markdown</em><br>
                <em>Part of XOS Framework Documentation</em></p>
            </div>
        </main>
    </div>

    <script>
        // Copy code functionality
        function copyCode(button, codeId) {
            const codeElement = document.getElementById(codeId);
            const text = codeElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        // Collapsible sections
        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('expanded');
        }
    </script>
</body>
</html>: '<rootDir>/src/$1',
    '\\.(css|less|scss|sass)
            
            <div class="footer">
                <p><em>Auto-generated from Markdown</em><br>
                <em>Part of XOS Framework Documentation</em></p>
            </div>
        </main>
    </div>

    <script>
        // Copy code functionality
        function copyCode(button, codeId) {
            const codeElement = document.getElementById(codeId);
            const text = codeElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        // Collapsible sections
        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('expanded');
        }
    </script>
</body>
</html>: 'identity-obj-proxy',
    '\\.(jpg|jpeg|png|gif|svg)
            
            <div class="footer">
                <p><em>Auto-generated from Markdown</em><br>
                <em>Part of XOS Framework Documentation</em></p>
            </div>
        </main>
    </div>

    <script>
        // Copy code functionality
        function copyCode(button, codeId) {
            const codeElement = document.getElementById(codeId);
            const text = codeElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        // Collapsible sections
        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('expanded');
        }
    </script>
</body>
</html>: '<rootDir>/__mocks__/fileMock.js',
  },
  transform: {
    '^.+\\.(ts|tsx)
            
            <div class="footer">
                <p><em>Auto-generated from Markdown</em><br>
                <em>Part of XOS Framework Documentation</em></p>
            </div>
        </main>
    </div>

    <script>
        // Copy code functionality
        function copyCode(button, codeId) {
            const codeElement = document.getElementById(codeId);
            const text = codeElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        // Collapsible sections
        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('expanded');
        }
    </script>
</body>
</html>: ['ts-jest', {
      tsconfig: {
        jsx: 'react-jsx',
      },
    }],
  },
};
</code></pre></div></p><p><h3>3. Setup File</h3></p><p><strong>src/setupTests.ts</strong>:
<div class="code-block"><pre><code>typescript
import '@testing-library/jest-dom';
import { cleanup } from '@testing-library/react';
import { server } from './mocks/server';</p><p>// Establish API mocking before all tests
beforeAll(() => server.listen({ onUnhandledRequest: 'error' }));</p><p>// Reset any request handlers that we may add during the tests
afterEach(() => {
  cleanup();
  server.resetHandlers();
});</p><p>// Clean up after the tests are finished
afterAll(() => server.close());</p><p>// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(),
    removeListener: jest.fn(),
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
});
</code></pre></div></p><p><h2>Testing Fundamentals</h2></p><p><h3>Basic Component Test</h3></p><p><div class="code-block"><pre><code>typescript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button } from './Button';</p><p>describe('Button Component', () => {
  it('renders with text', () => {
    render(<Button>Click me</Button>);
    
    const button = screen.getByRole('button', { name: /click me/i });
    expect(button).toBeInTheDocument();
  });</p><p>  it('calls onClick handler when clicked', async () => {
    const handleClick = jest.fn();
    const user = userEvent.setup();
    
    render(<Button onClick={handleClick}>Click me</Button>);
    
    const button = screen.getByRole('button');
    await user.click(button);
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });</p><p>  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Disabled Button</Button>);
    
    const button = screen.getByRole('button');
    expect(button).toBeDisabled();
  });
});
</code></pre></div></p><p><h3>Query Priorities</h3></p><p>React Testing Library recommends queries in this order:</p><p><div class="code-block"><pre><code>typescript
// 1. Queries accessible to everyone (preferred)
screen.getByRole('button', { name: /submit/i });
screen.getByLabelText(/email/i);
screen.getByPlaceholderText(/search/i);
screen.getByText(/loading/i);</p><p>// 2. Semantic queries
screen.getByAltText(/profile picture/i);
screen.getByTitle(/close/i);</p><p>// 3. Test IDs (last resort)
screen.getByTestId('custom-element');
</code></pre></div></p><p><h2>Component Testing</h2></p><p><h3>Testing Props and State</h3></p><p><div class="code-block"><pre><code>typescript
interface UserCardProps {
  user: {
    id: number;
    name: string;
    email: string;
    role: 'admin' | 'user';
  };
  onEdit?: (id: number) => void;
  onDelete?: (id: number) => void;
}</p><p>const UserCard: React.FC<UserCardProps> = ({ user, onEdit, onDelete }) => {
  const [isExpanded, setIsExpanded] = useState(false);</p><p>  return (
    <div data-testid="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      {user.role === 'admin' && <span>Admin</span>}
      
      <button onClick={() => setIsExpanded(!isExpanded)}>
        {isExpanded ? 'Collapse' : 'Expand'}
      </button>
      
      {isExpanded && (
        <div data-testid="user-details">
          <p>ID: {user.id}</p>
          <p>Role: {user.role}</p>
        </div>
      )}
      
      {onEdit && (
        <button onClick={() => onEdit(user.id)}>Edit</button>
      )}
      {onDelete && (
        <button onClick={() => onDelete(user.id)}>Delete</button>
      )}
    </div>
  );
};</p><p>// Tests
describe('UserCard', () => {
  const mockUser = {
    id: 1,
    name: 'John Doe',
    email: 'john@example.com',
    role: 'user' as const,
  };</p><p>  it('renders user information', () => {
    render(<UserCard user={mockUser} />);
    
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
    expect(screen.queryByText('Admin')).not.toBeInTheDocument();
  });</p><p>  it('shows admin badge for admin users', () => {
    const adminUser = { ...mockUser, role: 'admin' as const };
    render(<UserCard user={adminUser} />);
    
    expect(screen.getByText('Admin')).toBeInTheDocument();
  });</p><p>  it('toggles expanded state', async () => {
    const user = userEvent.setup();
    render(<UserCard user={mockUser} />);
    
    // Initially collapsed
    expect(screen.queryByTestId('user-details')).not.toBeInTheDocument();
    
    // Click to expand
    await user.click(screen.getByText('Expand'));
    expect(screen.getByTestId('user-details')).toBeInTheDocument();
    
    // Click to collapse
    await user.click(screen.getByText('Collapse'));
    expect(screen.queryByTestId('user-details')).not.toBeInTheDocument();
  });</p><p>  it('calls onEdit when edit button is clicked', async () => {
    const handleEdit = jest.fn();
    const user = userEvent.setup();
    
    render(<UserCard user={mockUser} onEdit={handleEdit} />);
    
    await user.click(screen.getByText('Edit'));
    expect(handleEdit).toHaveBeenCalledWith(1);
  });</p><p>  it('does not render action buttons when handlers are not provided', () => {
    render(<UserCard user={mockUser} />);
    
    expect(screen.queryByText('Edit')).not.toBeInTheDocument();
    expect(screen.queryByText('Delete')).not.toBeInTheDocument();
  });
});
</code></pre></div></p><p><h3>Testing Forms</h3></p><p><div class="code-block"><pre><code>typescript
interface LoginFormProps {
  onSubmit: (data: { email: string; password: string }) => void;
}</p><p>const LoginForm: React.FC<LoginFormProps> = ({ onSubmit }) => {
  const [errors, setErrors] = useState<Record<string, string>>({});</p><p>  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    const email = formData.get('email') as string;
    const password = formData.get('password') as string;</p><p>    const newErrors: Record<string, string> = {};
    if (!email) newErrors.email = 'Email is required';
    if (!password) newErrors.password = 'Password is required';
    if (password && password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    }</p><p>    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return;
    }</p><p>    onSubmit({ email, password });
  };</p><p>  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label htmlFor="email">Email</label>
        <input
          id="email"
          name="email"
          type="email"
          aria-invalid={!!errors.email}
          aria-describedby={errors.email ? 'email-error' : undefined}
        />
        {errors.email && (
          <span id="email-error" role="alert">
            {errors.email}
          </span>
        )}
      </div></p><p>      <div>
        <label htmlFor="password">Password</label>
        <input
          id="password"
          name="password"
          type="password"
          aria-invalid={!!errors.password}
          aria-describedby={errors.password ? 'password-error' : undefined}
        />
        {errors.password && (
          <span id="password-error" role="alert">
            {errors.password}
          </span>
        )}
      </div></p><p>      <button type="submit">Login</button>
    </form>
  );
};</p><p>// Tests
describe('LoginForm', () => {
  it('submits form with valid data', async () => {
    const handleSubmit = jest.fn();
    const user = userEvent.setup();
    
    render(<LoginForm onSubmit={handleSubmit} />);
    
    await user.type(screen.getByLabelText(/email/i), 'test@example.com');
    await user.type(screen.getByLabelText(/password/i), 'password123');
    await user.click(screen.getByRole('button', { name: /login/i }));
    
    expect(handleSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123',
    });
  });</p><p>  it('shows validation errors for empty fields', async () => {
    const handleSubmit = jest.fn();
    const user = userEvent.setup();
    
    render(<LoginForm onSubmit={handleSubmit} />);
    
    await user.click(screen.getByRole('button', { name: /login/i }));
    
    expect(screen.getByText('Email is required')).toBeInTheDocument();
    expect(screen.getByText('Password is required')).toBeInTheDocument();
    expect(handleSubmit).not.toHaveBeenCalled();
  });</p><p>  it('shows error for short password', async () => {
    const handleSubmit = jest.fn();
    const user = userEvent.setup();
    
    render(<LoginForm onSubmit={handleSubmit} />);
    
    await user.type(screen.getByLabelText(/email/i), 'test@example.com');
    await user.type(screen.getByLabelText(/password/i), 'short');
    await user.click(screen.getByRole('button', { name: /login/i }));
    
    expect(screen.getByText('Password must be at least 8 characters')).toBeInTheDocument();
    expect(handleSubmit).not.toHaveBeenCalled();
  });
});
</code></pre></div></p><p><h2>Hook Testing</h2></p><p><h3>Custom Hook Testing</h3></p><p><div class="code-block"><pre><code>typescript
// useCounter.ts
import { useState, useCallback } from 'react';</p><p>interface UseCounterOptions {
  initialValue?: number;
  min?: number;
  max?: number;
}</p><p>export const useCounter = (options: UseCounterOptions = {}) => {
  const { initialValue = 0, min = -Infinity, max = Infinity } = options;
  const [count, setCount] = useState(initialValue);</p><p>  const increment = useCallback(() => {
    setCount(c => Math.min(c + 1, max));
  }, [max]);</p><p>  const decrement = useCallback(() => {
    setCount(c => Math.max(c - 1, min));
  }, [min]);</p><p>  const reset = useCallback(() => {
    setCount(initialValue);
  }, [initialValue]);</p><p>  const set = useCallback((value: number) => {
    setCount(Math.min(Math.max(value, min), max));
  }, [min, max]);</p><p>  return { count, increment, decrement, reset, set };
};</p><p>// useCounter.test.ts
import { renderHook, act } from '@testing-library/react';
import { useCounter } from './useCounter';</p><p>describe('useCounter', () => {
  it('initializes with default value', () => {
    const { result } = renderHook(() => useCounter());
    expect(result.current.count).toBe(0);
  });</p><p>  it('initializes with custom value', () => {
    const { result } = renderHook(() => useCounter({ initialValue: 10 }));
    expect(result.current.count).toBe(10);
  });</p><p>  it('increments counter', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });</p><p>  it('respects max value', () => {
    const { result } = renderHook(() => 
      useCounter({ initialValue: 5, max: 5 })
    );
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(5);
  });</p><p>  it('respects min value', () => {
    const { result } = renderHook(() => 
      useCounter({ initialValue: 0, min: 0 })
    );
    
    act(() => {
      result.current.decrement();
    });
    
    expect(result.current.count).toBe(0);
  });</p><p>  it('resets to initial value', () => {
    const { result } = renderHook(() => 
      useCounter({ initialValue: 5 })
    );
    
    act(() => {
      result.current.increment();
      result.current.increment();
    });
    
    expect(result.current.count).toBe(7);
    
    act(() => {
      result.current.reset();
    });
    
    expect(result.current.count).toBe(5);
  });
});
</code></pre></div></p><p><h3>Testing Hooks with Context</h3></p><p><div class="code-block"><pre><code>typescript
// AuthContext.tsx
interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  isLoading: boolean;
}</p><p>const AuthContext = createContext<AuthContextType | undefined>(undefined);</p><p>export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};</p><p>// useAuth.test.tsx
import { renderHook, waitFor } from '@testing-library/react';
import { AuthProvider, useAuth } from './AuthContext';</p><p>const wrapper = ({ children }: { children: React.ReactNode }) => (
  <AuthProvider>{children}</AuthProvider>
);</p><p>describe('useAuth', () => {
  it('throws error when used outside AuthProvider', () => {
    const { result } = renderHook(() => useAuth());
    
    expect(result.error).toEqual(
      Error('useAuth must be used within AuthProvider')
    );
  });</p><p>  it('provides auth context', () => {
    const { result } = renderHook(() => useAuth(), { wrapper });
    
    expect(result.current.user).toBeNull();
    expect(result.current.isLoading).toBe(false);
    expect(typeof result.current.login).toBe('function');
    expect(typeof result.current.logout).toBe('function');
  });</p><p>  it('handles login', async () => {
    const { result } = renderHook(() => useAuth(), { wrapper });
    
    act(() => {
      result.current.login('test@example.com', 'password');
    });
    
    await waitFor(() => {
      expect(result.current.user).toEqual({
        email: 'test@example.com',
        name: 'Test User',
      });
    });
  });
});
</code></pre></div></p><p><h2>Async Testing</h2></p><p><h3>Testing API Calls</h3></p><p><div class="code-block"><pre><code>typescript
// UserList.tsx
const UserList: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);</p><p>  useEffect(() => {
    const fetchUsers = async () => {
      try {
        setLoading(true);
        const response = await fetch('/api/users');
        if (!response.ok) throw new Error('Failed to fetch');
        const data = await response.json();
        setUsers(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };</p><p>    fetchUsers();
  }, []);</p><p>  if (loading) return <div>Loading users...</div>;
  if (error) return <div role="alert">Error: {error}</div>;
  if (users.length === 0) return <div>No users found</div>;</p><p>  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
};</p><p>// UserList.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import { rest } from 'msw';
import { setupServer } from 'msw/node';
import { UserList } from './UserList';</p><p>const server = setupServer(
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.json([
        { id: 1, name: 'John Doe' },
        { id: 2, name: 'Jane Smith' },
      ])
    );
  })
);</p><p>beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());</p><p>describe('UserList', () => {
  it('displays loading state initially', () => {
    render(<UserList />);
    expect(screen.getByText('Loading users...')).toBeInTheDocument();
  });</p><p>  it('displays users after successful fetch', async () => {
    render(<UserList />);
    
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
    });
    
    expect(screen.getByText('Jane Smith')).toBeInTheDocument();
    expect(screen.queryByText('Loading users...')).not.toBeInTheDocument();
  });</p><p>  it('displays error message on fetch failure', async () => {
    server.use(
      rest.get('/api/users', (req, res, ctx) => {
        return res(ctx.status(500));
      })
    );</p><p>    render(<UserList />);
    
    await waitFor(() => {
      expect(screen.getByRole('alert')).toHaveTextContent('Error: Failed to fetch');
    });
  });</p><p>  it('displays message when no users are returned', async () => {
    server.use(
      rest.get('/api/users', (req, res, ctx) => {
        return res(ctx.json([]));
      })
    );</p><p>    render(<UserList />);
    
    await waitFor(() => {
      expect(screen.getByText('No users found')).toBeInTheDocument();
    });
  });
});
</code></pre></div></p><p><h3>Testing Timers and Delays</h3></p><p><div class="code-block"><pre><code>typescript
// Notification.tsx
const Notification: React.FC<{ message: string; duration?: number }> = ({ 
  message, 
  duration = 3000 
}) => {
  const [visible, setVisible] = useState(true);</p><p>  useEffect(() => {
    const timer = setTimeout(() => {
      setVisible(false);
    }, duration);</p><p>    return () => clearTimeout(timer);
  }, [duration]);</p><p>  if (!visible) return null;</p><p>  return (
    <div role="alert" className="notification">
      {message}
    </div>
  );
};</p><p>// Notification.test.tsx
describe('Notification', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });</p><p>  afterEach(() => {
    jest.runOnlyPendingTimers();
    jest.useRealTimers();
  });</p><p>  it('displays message', () => {
    render(<Notification message="Test notification" />);
    expect(screen.getByRole('alert')).toHaveTextContent('Test notification');
  });</p><p>  it('disappears after default duration', () => {
    render(<Notification message="Test" />);
    
    expect(screen.getByRole('alert')).toBeInTheDocument();
    
    act(() => {
      jest.advanceTimersByTime(3000);
    });
    
    expect(screen.queryByRole('alert')).not.toBeInTheDocument();
  });</p><p>  it('respects custom duration', () => {
    render(<Notification message="Test" duration={5000} />);
    
    act(() => {
      jest.advanceTimersByTime(3000);
    });
    expect(screen.getByRole('alert')).toBeInTheDocument();
    
    act(() => {
      jest.advanceTimersByTime(2000);
    });
    expect(screen.queryByRole('alert')).not.toBeInTheDocument();
  });
});
</code></pre></div></p><p><h2>Mocking Strategies</h2></p><p><h3>MSW (Mock Service Worker) Setup</h3></p><p><div class="code-block"><pre><code>typescript
// mocks/handlers.ts
import { rest } from 'msw';</p><p>export const handlers = [
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.json([
        { id: 1, name: 'John Doe', email: 'john@example.com' },
        { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
      ])
    );
  }),</p><p>  rest.post('/api/login', async (req, res, ctx) => {
    const { email, password } = await req.json();
    
    if (email === 'test@example.com' && password === 'password') {
      return res(
        ctx.json({
          token: 'fake-jwt-token',
          user: { email, name: 'Test User' },
        })
      );
    }
    
    return res(
      ctx.status(401),
      ctx.json({ message: 'Invalid credentials' })
    );
  }),</p><p>  rest.delete('/api/users/:id', (req, res, ctx) => {
    const { id } = req.params;
    return res(ctx.json({ success: true, deletedId: id }));
  }),
];</p><p>// mocks/server.ts
import { setupServer } from 'msw/node';
import { handlers } from './handlers';</p><p>export const server = setupServer(...handlers);
</code></pre></div></p><p><h3>Module Mocking</h3></p><p><div class="code-block"><pre><code>typescript
// Mocking a module
jest.mock('@/services/api', () => ({
  apiClient: {
    get: jest.fn(),
    post: jest.fn(),
    put: jest.fn(),
    delete: jest.fn(),
  },
}));</p><p>// Mocking with implementation
jest.mock('@/hooks/useFeatureFlag', () => ({
  useFeatureFlag: jest.fn((flag: string) => {
    const flags: Record<string, boolean> = {
      'new-feature': true,
      'experimental': false,
    };
    return flags[flag] ?? false;
  }),
}));</p><p>// Partial mocking
jest.mock('@/utils', () => ({
  ...jest.requireActual('@/utils'),
  formatDate: jest.fn(() => '2024-01-01'),
}));
</code></pre></div></p><p><h3>Mocking Context and Providers</h3></p><p><div class="code-block"><pre><code>typescript
// Test utilities
const renderWithProviders = (
  ui: React.ReactElement,
  {
    preloadedState = {},
    store = configureStore({ reducer: rootReducer, preloadedState }),
    ...renderOptions
  } = {}
) => {
  const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (
    <Provider store={store}>
      <ThemeProvider theme={theme}>
        <Router>
          {children}
        </Router>
      </ThemeProvider>
    </Provider>
  );</p><p>  return { store, ...render(ui, { wrapper: Wrapper, ...renderOptions }) };
};</p><p>// Usage in tests
describe('Component with providers', () => {
  it('renders with custom store state', () => {
    const preloadedState = {
      user: { isAuthenticated: true, name: 'Test User' },
    };
    
    const { store } = renderWithProviders(<Dashboard />, { preloadedState });
    
    expect(screen.getByText('Welcome, Test User')).toBeInTheDocument();
  });
});
</code></pre></div></p><p><h2>Integration Testing</h2></p><p><h3>Testing Component Interactions</h3></p><p><div class="code-block"><pre><code>typescript
// TodoApp integration test
describe('TodoApp Integration', () => {
  it('completes full todo workflow', async () => {
    const user = userEvent.setup();
    render(<TodoApp />);
    
    // Add a todo
    const input = screen.getByPlaceholderText(/add a todo/i);
    const addButton = screen.getByRole('button', { name: /add/i });
    
    await user.type(input, 'Write tests');
    await user.click(addButton);
    
    // Verify todo appears
    expect(screen.getByText('Write tests')).toBeInTheDocument();
    expect(input).toHaveValue('');
    
    // Mark as complete
    const checkbox = screen.getByRole('checkbox');
    await user.click(checkbox);
    
    expect(checkbox).toBeChecked();
    expect(screen.getByText('Write tests')).toHaveStyle({
      textDecoration: 'line-through',
    });
    
    // Filter completed todos
    const filterButton = screen.getByRole('button', { name: /active/i });
    await user.click(filterButton);
    
    expect(screen.queryByText('Write tests')).not.toBeInTheDocument();
    
    // Delete todo
    await user.click(screen.getByRole('button', { name: /all/i }));
    const deleteButton = screen.getByRole('button', { name: /delete/i });
    await user.click(deleteButton);
    
    expect(screen.queryByText('Write tests')).not.toBeInTheDocument();
  });
});
</code></pre></div></p><p><h3>Testing with React Router</h3></p><p><div class="code-block"><pre><code>typescript
// Testing navigation
import { MemoryRouter, Route, Routes } from 'react-router-dom';</p><p>const renderWithRouter = (ui: React.ReactElement, { route = '/' } = {}) => {
  return render(
    <MemoryRouter initialEntries={[route]}>
      {ui}
    </MemoryRouter>
  );
};</p><p>describe('Navigation', () => {
  it('navigates to user profile', async () => {
    const user = userEvent.setup();
    
    renderWithRouter(
      <Routes>
        <Route path="/" element={<UserList />} />
        <Route path="/users/:id" element={<UserProfile />} />
      </Routes>
    );
    
    // Click on a user link
    await user.click(screen.getByRole('link', { name: /john doe/i }));
    
    // Verify navigation occurred
    await waitFor(() => {
      expect(screen.getByText('User Profile')).toBeInTheDocument();
      expect(screen.getByText('John Doe')).toBeInTheDocument();
    });
  });
});
</code></pre></div></p><p><h2>Best Practices</h2></p><p><h3>1. Test Organization</h3></p><p><div class="code-block"><pre><code>typescript
// Organize tests by feature/component
describe('UserDashboard', () => {
  describe('when user is authenticated', () => {
    beforeEach(() => {
      // Setup authenticated state
    });</p><p>    it('displays user information', () => {});
    it('shows personalized content', () => {});
    
    describe('when user has admin role', () => {
      it('displays admin controls', () => {});
    });
  });</p><p>  describe('when user is not authenticated', () => {
    it('redirects to login', () => {});
  });
});
</code></pre></div></p><p><h3>2. Custom Render Functions</h3></p><p><div class="code-block"><pre><code>typescript
// test-utils.tsx
import { ReactElement } from 'react';
import { render, RenderOptions } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from 'react-query';</p><p>const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: { retry: false },
    mutations: { retry: false },
  },
});</p><p>const AllTheProviders: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const testQueryClient = createTestQueryClient();
  
  return (
    <QueryClientProvider client={testQueryClient}>
      {children}
    </QueryClientProvider>
  );
};</p><p>const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => render(ui, { wrapper: AllTheProviders, ...options });</p><p>export </em> from '@testing-library/react';
export { customRender as render };
</code></pre></div></p><p><h3>3. Accessibility Testing</h3></p><p><div class="code-block"><pre><code>typescript
import { axe, toHaveNoViolations } from 'jest-axe';</p><p>expect.extend(toHaveNoViolations);</p><p>describe('Accessibility', () => {
  it('has no accessibility violations', async () => {
    const { container } = render(<LoginForm onSubmit={jest.fn()} />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });</p><p>  it('has proper ARIA attributes', () => {
    render(<Modal isOpen title="Confirm" />);
    
    const dialog = screen.getByRole('dialog');
    expect(dialog).toHaveAttribute('aria-labelledby');
    expect(dialog).toHaveAttribute('aria-modal', 'true');
  });
});
</code></pre></div></p><p><h3>4. Snapshot Testing</h3></p><p>``<code>typescript
describe('Button', () => {
  it('matches snapshot', () => {
    const { container } = render(
      <Button variant="primary" size="large">
        Click me
      </Button>
    );
    
    expect(container.firstChild).toMatchSnapshot();
  });</p><p>  // More focused snapshot
  it('matches inline snapshot', () => {
    const { container } = render(<Button>Test</Button>);
    
    expect(container.firstChild).toMatchInlineSnapshot(</code>
      <button
        class="btn btn-default"
        type="button"
      >
        Test
      </button>
    <code>);
  });
});
<div class="code-block"><pre><code></p><p><h3>5. Testing Error Boundaries</h3></p><p></code></pre></div>typescript
// ErrorBoundary.test.tsx
const ThrowError = ({ shouldThrow }: { shouldThrow: boolean }) => {
  if (shouldThrow) {
    throw new Error('Test error');
  }
  return <div>No error</div>;
};</p><p>describe('ErrorBoundary', () => {
  // Suppress console.error for this test
  const originalError = console.error;
  beforeAll(() => {
    console.error = jest.fn();
  });
  afterAll(() => {
    console.error = originalError;
  });</p><p>  it('catches errors and displays fallback', () => {
    render(
      <ErrorBoundary fallback={<div>Error occurred</div>}>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );
    
    expect(screen.getByText('Error occurred')).toBeInTheDocument();
    expect(screen.queryByText('No error')).not.toBeInTheDocument();
  });</p><p>  it('renders children when there is no error', () => {
    render(
      <ErrorBoundary fallback={<div>Error occurred</div>}>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    );
    
    expect(screen.getByText('No error')).toBeInTheDocument();
    expect(screen.queryByText('Error occurred')).not.toBeInTheDocument();
  });
});
<div class="code-block"><pre><code></p><p><h2>Common Patterns and Anti-Patterns</h2></p><p><h3>? Good Practices</h3></p><p></code></pre></div>typescript
// Good: Testing user behavior
it('submits form when user fills all fields', async () => {
  const user = userEvent.setup();
  const onSubmit = jest.fn();
  render(<ContactForm onSubmit={onSubmit} />);
  
  await user.type(screen.getByLabelText(/name/i), 'John');
  await user.type(screen.getByLabelText(/email/i), 'john@example.com');
  await user.click(screen.getByRole('button', { name: /submit/i }));
  
  expect(onSubmit).toHaveBeenCalledWith({
    name: 'John',
    email: 'john@example.com',
  });
});</p><p>// Good: Using semantic queries
const button = screen.getByRole('button', { name: /save/i });
const input = screen.getByLabelText(/username/i);</p><p>// Good: Waiting for async operations
await waitFor(() => {
  expect(screen.getByText(/success/i)).toBeInTheDocument();
});
<div class="code-block"><pre><code></p><p><h3>? Anti-Patterns to Avoid</h3></p><p></code></pre></div>typescript
// Bad: Testing implementation details
it('sets state correctly', () => {
  // Don't test state directly
  expect(component.state.isOpen).toBe(true);
});</p><p>// Bad: Using container queries
const button = container.querySelector('.btn-primary');</p><p>// Bad: Testing internals
it('calls internal method', () => {
  const instance = wrapper.instance();
  instance.handleClick(); // Don't test private methods
});</p><p>// Bad: Overusing test IDs
const element = screen.getByTestId('my-element');
// Prefer semantic queries instead
<div class="code-block"><pre><code></p><p><h2>Performance Optimization</h2></p><p><h3>1. Optimize Test Setup</h3></p><p></code></pre></div>typescript
// Share expensive setup between tests
describe('ExpensiveComponent', () => {
  let expensiveData: any;</p><p>  beforeAll(async () => {
    // Expensive one-time setup
    expensiveData = await generateLargeDataset();
  });</p><p>  beforeEach(() => {
    // Cheap per-test setup
    jest.clearAllMocks();
  });</p><p>  // Tests use shared expensiveData
});
</code>`<code></p><p><h3>2. Use </code>screen` for Queries</h3></p><p><div class="code-block"><pre><code>typescript
// Good: Using screen (no need to destructure)
import { render, screen } from '@testing-library/react';</p><p>render(<Component />);
const element = screen.getByText(/hello/i);</p><p>// Less optimal: Destructuring from render
const { getByText } = render(<Component />);
const element = getByText(/hello/i);
</code></pre></div></p><p><h2>Summary</h2></p><p>Key takeaways for effective React testing:</p><p><ul><li><strong>Test user behavior</strong> - Focus on how users interact with components</li><li><strong>Use Testing Library queries properly</strong> - Follow the priority guidelines</li><li><strong>Keep tests maintainable</strong> - Avoid testing implementation details</li><li><strong>Mock strategically</strong> - Use MSW for API mocking</li><li><strong>Test accessibility</strong> - Ensure components are accessible</li><li><strong>Write clear test names</strong> - They serve as documentation</li><li><strong>Use proper async patterns</strong> - waitFor, findBy queries</li><li><strong>Organize tests well</strong> - Group related tests with describe blocks</li></ul></p><p>Remember: The more your tests resemble the way your software is used, the more confidence they can give you!</p>
            
            <div class="footer">
                <p><em>Auto-generated from Markdown</em><br>
                <em>Part of XOS Framework Documentation</em></p>
            </div>
        </main>
    </div>

    <script>
        // Copy code functionality
        function copyCode(button, codeId) {
            const codeElement = document.getElementById(codeId);
            const text = codeElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        // Collapsible sections
        function toggleCollapsible(header) {
            const collapsible = header.parentElement;
            collapsible.classList.toggle('expanded');
        }
    </script>
</body>
</html>
